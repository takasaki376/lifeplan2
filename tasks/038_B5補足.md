## 1) Decision（確定事項）

B5（IndexedDB Repository 実装）で迷いが出やすい 5 点について、**MVP として破綻しにくい一貫方針**を確定します。

---

## 2) Assumption（仮定）

- B4 で決めた方針どおり、**例外は throw**（Result/Either なし）。
- **CurrentVersion の正（source of truth）は `Plan.currentVersionId`**（二重管理は避ける／やむなくある場合も Plan 側を正）。
- 3 シナリオ（conservative/base/optimistic）は UI/URL 連動（D7/D5/G1-1）で前提になっている。

---

## 3) Design Output（不明点への回答）

### ① `VersionRepository.createInitial` の振る舞い

**結論：`versionNo=1`、作成した Version を current にし、`Plan.currentVersionId` まで同一 tx で更新する前提で OK。**

- `versionNo` 初期値：**1**
- current 整合：

  - `Plan.currentVersionId = createdVersion.id` を同一 tx で更新（必須）
  - `PlanVersion.isCurrent` を持っているなら **書き換えても良いが、正は Plan.currentVersionId**（できれば isCurrent は持たない/派生）

- 追加でやるかどうか（任意）：

  - `createdAt/updatedAt` の付与は Repo 側生成（B4 方針）
  - ここで scenario/housing の初期投入までやると責務が肥大化するので、**createInitial は「version 作成＋ current 化」まで**に留め、初期前提投入は C3（または ensure 系）へ

---

### ② `MonthlyRepository.copyFromPreviousMonth`：前月が無いときの挙動

**結論：前月が無い場合は “作らない” で、`NotFound` 相当を throw が一番きれい。**

理由：

- UI（E4）では「前月が無い」をメッセージ表示したい（toast 等）
- Repo が勝手に空レコードを作ると、「未入力判定」や「入力済み判定」が崩れやすい

推奨仕様：

- 前月 `MonthlyRecord` が存在しない → `throw new RepoNotFoundError('MonthlyRecord', { planId, prevYm })`
- 呼び出し側（E4 usecase/UI）で catch して「前月データがありません」表示

---

### ③ `VersionRepository.delete`：現行 version の削除禁止で良いか

**結論：現行 version（`plan.currentVersionId === versionId`）の削除は常に禁止（throw）で OK。**

理由：

- current が消えると、ダッシュボードや各画面の前提が参照不能になりやすい
- 「削除したい」場合の正しい手順は「別 version を current にしてから削除」

推奨：

- `delete(versionId)` の中で `Plan.currentVersionId` を確認し、一致なら throw
- ついでに安全策（任意）：

  - version が 1 つしかないケース＝必ず current なので上記で自然に防げる

---

### ④ `VersionRepository.ensureScenarioSet`：3 シナリオをどう作るか

**結論：`conservative/base/optimistic` の 3 つを必ず作る（空ではなく“最低限のデフォルト値あり”推奨）。**

理由：

- UI/URL で 3 シナリオ切替が前提
- base のみだと、後から「不足を埋める分岐」が増える

デフォルト値の方針（MVP）：

- **「意味のある最小デフォルト」**を持たせる（全部 0 は比較の価値が出づらい）
- 例（あくまで初期値、ユーザーが後で編集する前提）：

  - `base`: inflation 2% / rentIncrease 1% / utilitiesIncrease 1%
  - `conservative`: inflation 3% / rentIncrease 2% / utilitiesIncrease 2%
  - `optimistic`: inflation 1% / rentIncrease 0% / utilitiesIncrease 0%

実装の落とし所：

- `src/lib/domain/defaults/scenario.ts` に `DEFAULT_SCENARIO_SET` を定義
- `ensureScenarioSet(versionId)` は

  - 既に 3 つ揃っていれば何もしない
  - 足りない分だけ upsert（既存は上書きしない）

---

### ⑤ `HousingRepository.applyPreset`：データソース未定義

**結論：MVP は “未実装で throw” より、`DEFAULT_HOUSING_PRESET` をコード内定義して実装するのが良い（最小で）。**

理由：

- C3（初期前提投入）や G5（前提編集）で「初期値」が無いと UX が成立しづらい
- 「データソース未定義」を理由に throw すると、後続チケットが詰まりやすい

推奨実装：

- `src/lib/domain/defaults/housing.ts` に、4 タイプ分の最小前提を **“MVP 初期値”として固定**（後で編集可能）
- `applyPreset(versionId, presetKey='default')` は

  - presetKey が `default` のみ対応（それ以外は throw）で OK
  - `bulkUpsert` で 4 タイプを投入（すでにある場合は上書きする/しないを決める）

    - MVP は「未設定のみ投入」がおすすめ（ユーザー編集を潰さない）

※もし「初期投入は C3 だけでやる」方針なら、`applyPreset` 自体を **B5 ではスタブ（throw）**にしても良いですが、その場合は **C3 の実装で同等のデフォルト定義が必ず必要**になります。詰まりやすいので、私は「デフォルト定義を用意して applyPreset を実装」を推奨します。

---

## 4) Risks（リスク）

- `copyFromPreviousMonth` が空レコード作成だと、未入力判定・入力済み判定がズレる（地味にバグる） → throw 推奨。
- ScenarioSet を base のみ作ると、画面側が「足りない分岐」だらけになる → 3 つ常備が安全。
- `applyPreset` を throw にすると、C3/G5 のどこかで必ず同じ“初期値問題”にぶつかる → デフォルトはコード内に置くのが早い。

---

## 5) Next（次に作るべきもの：最短ルート）

B5 開始の最短ルートはこれです：

1. `RepoError / RepoNotFoundError` を用意（or 最小の Error ラップ）
2. `VersionRepo.createInitial` を **同一 tx で Plan.currentVersionId まで更新**
3. `VersionRepo.ensureScenarioSet` を **3 シナリオ＋デフォルト値**で実装
4. `MonthlyRepo.copyFromPreviousMonth` は **前月なし throw**
5. `HousingRepo.applyPreset` は **DEFAULT preset 実装（default のみ対応）**
