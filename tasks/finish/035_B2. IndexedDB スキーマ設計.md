# Jira チケット（B2）IndexedDB スキーマ設計（objectStore・index・versioning）

## Summary

B2. IndexedDB スキーマ設計（objectStore・index・versioning）

## Issue Type

Story（または Task）

## Priority

High

## Background / Context

MVP は IndexedDB で永続化する。今後の B3（IndexedDB ラッパー）/ B5（Repo 実装）/ UI 実装の土台として、  
**objectStore 構成・キー設計・index 設計・schema versioning（upgrade 戦略）** を先に確定する。

B1 で定義したドメインモデル（Plan / PlanVersion / MonthlyRecord / LifeEvent / HousingAssumptions）に整合することが必須。

## Goal

- 参照パターン（一覧・検索・当月取得・version 単位の取得）に最適な objectStore と index を定義する
- 月次やイベントの「年月キー」を軸に高速に取れるようにする
- スキーマ変更（MVP 進行中の追加カラム/Store 追加）に耐える upgrade 設計を用意する

## In Scope

- DB 名/DB バージョン/ストア名/主キー/インデックスの設計
- 複合キー（例：planId+ym）の方針策定（index で対応 or compound key）
- versioning（onupgradeneeded）の方針（v1→v2→…の差分設計）
- seed/デバッグ（初期データ投入・全削除）をやる前提の設計メモ（実装は B3/K 系へ）

## Out of Scope

- IndexedDB API の実装（B3）
- Repository 実装（B5）
- Zod 等のバリデーション（J1）
- Supabase スキーマ（将来）

## Deliverables

- `docs/indexeddb-schema.md`（または `src/lib/db/schema.ts` コメントでも可）に以下を定義
  - DB 名（例：`lifeplan_mvp`）
  - DB バージョン（初期は `1`）
  - objectStore 一覧（用途/主キー）
  - index 一覧（keyPath/unique/multiEntry）
  - upgrade 方針（v1→v2…の追加手順のテンプレ）
- B3 実装者がそのまま実装できる粒度で記述されていること

---

## Data Access Patterns（想定クエリ）

必ず満たすこと（index 設計の根拠）：

### プラン

- プラン一覧（userId 別 / status 別 / updatedAt 降順）
- プラン単体取得（planId）
- currentVersionId の取得（planId から参照）

### 改定（PlanVersion）

- planId に紐づく version 一覧（versionNo 降順）
- currentVersion（isCurrent=true）を 1 件取得

### 月次（MonthlyRecord / MonthlyItem）

- planId + ym（特定月）を 1 件取得
- planId の月次一覧（年でフィルタ、ym 降順）
- planId の最新月（ym max）
- monthlyRecordId に紐づく monthlyItems 一覧
- planId + ym の削除（record + items）

### ライフイベント（LifeEvent）

- planVersionId のイベント一覧
- planVersionId で今後（startYm >= nowYm）と過去のフィルタ
- startYm 昇順で直近 3 件

### 住宅前提（HousingAssumptions）

- planVersionId の 4 タイプ一括取得
- planVersionId + housingType の取得
- planVersionId 内で isSelected=true の取得（任意）

---

## Proposed IndexedDB Schema（提案）

### DB

- name: `lifeplan_mvp`
- version: `1`

### objectStores

#### 1) `plans`

- keyPath: `id`（string uuid）
- indexes:
  - `by_userId` → `userId`（unique: false）
  - `by_status` → `status`（unique: false）
  - `by_archivedAt` → `archivedAt`（unique: false）
  - `by_updatedAt` → `updatedAt`（unique: false）
  - `by_userId_status` → `['userId','status']`（unique: false）※必要なら
  - `by_userId_updatedAt` → `['userId','updatedAt']`（unique: false）※必要なら

#### 2) `planVersions`

- keyPath: `id`
- indexes:
  - `by_planId` → `planId`
  - `by_planId_versionNo` → `['planId','versionNo']`（unique: true）
  - `by_planId_isCurrent` → `['planId','isCurrent']`（unique: false）
    - 取得時は (planId, true) で絞り、アプリ側で 1 件保証（論理制約）
  - `by_createdAt` → `createdAt`（任意）

#### 3) `scenarioAssumptions`

- keyPath: `id`
- indexes:
  - `by_versionId` → `planVersionId`
  - `by_versionId_scenarioKey` → `['planVersionId','scenarioKey']`（unique: true）

#### 4) `monthlyRecords`

- keyPath: `id`
- indexes:
  - `by_planId` → `planId`
  - `by_planId_ym` → `['planId','ym']`（unique: true）
  - `by_planId_ym_desc` → `['planId','ym']`（unique: false）※同じだがカーソルで desc に使う
  - `by_ym` → `ym`（任意）
    ※ IndexedDB のソートは index の順 + cursor 方向で行うため、`by_planId_ym` を cursor("prev")で最新取得に使用。

#### 5) `monthlyItems`

- keyPath: `id`
- indexes:
  - `by_monthlyRecordId` → `monthlyRecordId`
  - `by_monthlyRecordId_kind` → `['monthlyRecordId','kind']`（unique: false）
  - `by_monthlyRecordId_category` → `['monthlyRecordId','category']`（unique: false）※任意

#### 6) `lifeEvents`

- keyPath: `id`
- indexes:
  - `by_versionId` → `planVersionId`
  - `by_versionId_startYm` → `['planVersionId','startYm']`（unique: false）
  - `by_versionId_direction` → `['planVersionId','direction']`（unique: false）※任意
  - `by_versionId_eventType` → `['planVersionId','eventType']`（unique: false）※任意

#### 7) `housingAssumptions`

- keyPath: `id`
- indexes:
  - `by_versionId` → `planVersionId`
  - `by_versionId_type` → `['planVersionId','housingType']`（unique: true）
  - `by_versionId_isSelected` → `['planVersionId','isSelected']`（unique: false）※任意

#### （任意）8) `snapshots_lcc`

- MVP では作らなくても OK（後で v2 で追加推奨）
- keyPath: `id`
- indexes（案）:
  - `by_versionId_scenario_type_horizon` → `['planVersionId','scenarioKey','housingType','horizonYears']`（unique: true）

#### （任意）9) `snapshots_projection`

- MVP では作らなくても OK（後で v2 で追加推奨）
- keyPath: `id`
- indexes（案）:
  - `by_versionId_scenario_horizon` → `['planVersionId','scenarioKey','horizonMonths']`（unique: true）

---

## Key Design Notes

- `ym` / `startYm` は `"YYYY-MM"` 形式（文字列）を推奨  
  → 文字列比較で月順が崩れない（"2026-01" < "2026-10" も正しい）
- `monthlyRecords` は `['planId','ym']` の unique index で「特定月の 1 件」を保証
- 参照が多い `planVersionId` は必ず index を貼る
- `isCurrent` / `isSelected` は DB 制約で完全保証できないため、更新処理はトランザクションで 1 つに揃える（H1/G2 で実装）

---

## Versioning / Upgrade Strategy

- 初期: DB version = 1
- 以後の変更は **破壊的変更を避け、追加中心** にする
- upgrade テンプレ（実装は B3）：
  - v2: snapshots store 追加（`snapshots_lcc`, `snapshots_projection`）
  - v3: index 追加（クエリが重い箇所を計測して追加）
  - v4: store 分割（JSON 肥大化があれば `housingRepairs` 等を分離）

### Acceptance for upgrade design

- [ ] `onupgradeneeded` で version ごとの分岐が可能な設計
- [ ] store 追加/ index 追加が安全に行える（既存データ保持）
- [ ] 開発中の schema reset 手段（DB 削除）を README または docs に明記

---

## Acceptance Criteria

- [ ] objectStore 一覧（必須 7）と主キーが決まっている
- [ ] 想定クエリ（Data Access Patterns）を満たす index が設計されている
- [ ] `monthlyRecords` は `(planId, ym)` で一意取得できる
- [ ] `housingAssumptions` は `(planVersionId, housingType)` で一意取得できる
- [ ] versioning（upgrade 方針）が文書化されている
- [ ] B3（ラッパー実装）がこの設計で迷わず着手できる

## Definition of Done

- [ ] schema 設計がドキュメントとして PR に含まれている
- [ ] B1 の型との整合（store フィールド名）がレビュー済み
- [ ] 想定クエリで「どの index を使うか」が明記されている（箇条書きで OK）

## Dependencies

- B1（ドメインモデル型）が確定していること

## Follow-ups（関連チケット）

- B3. IndexedDB ラッパー実装（CRUD 共通）
- B5. IndexedDB Repository 実装（全 Repo）
- K1. デバッグ用「データ初期化」ボタン
