# Jira チケット（B4）Repository インターフェース定義（PlanRepo/MonthlyRepo/EventRepo/HousingRepo/VersionRepo）

## Summary

B4. Repository インターフェース定義（PlanRepo / MonthlyRepo / EventRepo / HousingRepo / VersionRepo）

## Issue Type

Story（または Task）

## Priority

High

## Background / Context

MVP は IndexedDB で永続化するが、将来的に Supabase に移行する想定。  
そのため、UI や計算ロジックから永続化実装を切り離し、**Repository インターフェース**を契約として定義する。

- B1：ドメインモデル（TypeScript 型）
- B2/B3：IndexedDB スキーマ＆ラッパー
- B4：Repository のインターフェース（ここ）
- B5：IndexedDB 実装（Repo 実装）
- B6：Supabase スタブ（差し替え準備）

## Goal

- UI/ユースケース層が依存する「永続化 API」の契約を決める
- IndexedDB/Supabase の差し替えが可能なインターフェースにする
- 主要ユースケース（一覧・作成・更新・削除・月次の upsert・前月コピー・現行 Version 取得など）を網羅する

---

## In Scope

- Repository インターフェース（TypeScript）定義
- 返却型・引数型（B1 の型）との整合
- 代表的な Query メソッド（一覧/フィルタ/取得/保存/削除）
- 例外/エラーの扱い方針（throw or Result 型のどちらかに統一）
- トランザクション要件の整理（Repo 内部で吸収 or 外でまとめるか）

## Out of Scope

- IndexedDB 実装（B5）
- Supabase 実装（B6）
- バリデーション（J1）
- UI 実装

---

## Deliverables

- `src/lib/repo/interfaces.ts`（例）に以下のインターフェースを定義
  - `PlanRepository`
  - `VersionRepository`
  - `MonthlyRepository`
  - `EventRepository`
  - `HousingRepository`
- `src/lib/repo/types.ts`（例）に Query/DTO（フィルタ・並び順など）を定義
- `src/lib/repo/index.ts`（例）でまとめて export

---

## Design Notes（設計方針）

- Repository の戻り値は原則 `Promise<T>`（非同期）
- 「作成/更新」は `upsert` を基本にし、UI から扱いやすくする
- 月次は `(planId, ym)` のユニーク前提で `upsertByYm` を用意
- Version は `getCurrent(planId)` を必須にする
- 住宅前提は `(planVersionId, housingType)` で取得できるようにする
- 例外は基本 `throw`（UI で toast 表示）。Result/Either は MVP では採用しない（必要なら将来）。

---

## Methods（要求 API 案）

### PlanRepository

- `list(params?: { userId?: Id; status?: "active"|"archived"; query?: string; sort?: "updatedAtDesc"|"createdAtDesc" }): Promise<Plan[]>`
- `get(planId: Id): Promise<Plan | undefined>`
- `create(input: Pick<Plan, "name"> & Partial<Pick<Plan,"householdType"|"note"|"userId">>): Promise<Plan>`
- `update(plan: Plan): Promise<void>`
- `archive(planId: Id): Promise<void>`
- `restore(planId: Id): Promise<void>`
- `delete(planId: Id): Promise<void>`
- `setCurrentVersion(planId: Id, versionId: Id): Promise<void>`（任意：plan に pointer 持つなら）

### VersionRepository

- `listByPlan(planId: Id): Promise<PlanVersion[]>`
- `get(versionId: Id): Promise<PlanVersion | undefined>`
- `getCurrent(planId: Id): Promise<PlanVersion | undefined>`
- `createFromCurrent(planId: Id, changeNote?: string): Promise<PlanVersion>`（新バージョン作成）
- `setCurrent(planId: Id, versionId: Id): Promise<void>`（isCurrent 整合を取る）
- `delete(versionId: Id): Promise<void>`（現行版削除不可の制約は Repo or usecase で）

### MonthlyRepository

- `getByYm(planId: Id, ym: YearMonth): Promise<MonthlyRecord | undefined>`
- `listByPlan(planId: Id, params?: { year?: number; sort?: "ymDesc"|"ymAsc" }): Promise<MonthlyRecord[]>`
- `upsert(record: MonthlyRecord): Promise<MonthlyRecord>`（id が無ければ生成は呼び出し側 or repo 側で）
- `upsertByYm(planId: Id, ym: YearMonth, patch: Partial<MonthlyRecord>): Promise<MonthlyRecord>`
- `copyFromPreviousMonth(planId: Id, ym: YearMonth): Promise<MonthlyRecord>`（前月が無い場合の挙動も定義）
- `deleteByYm(planId: Id, ym: YearMonth): Promise<void>`

#### MonthlyItem（詳細内訳）

- `listItems(monthlyRecordId: Id): Promise<MonthlyItem[]>`
- `replaceItems(monthlyRecordId: Id, items: MonthlyItem[]): Promise<void>`（詳細保存は replace が楽）
- `deleteItemsByRecord(monthlyRecordId: Id): Promise<void>`

### EventRepository

- `listByVersion(planVersionId: Id, params?: { scope?: "upcoming"|"past"|"all"; fromYm?: YearMonth; toYm?: YearMonth; type?: string; cadence?: "once"|"monthly"; direction?: "expense"|"income" }): Promise<LifeEvent[]>`
- `get(eventId: Id): Promise<LifeEvent | undefined>`
- `create(event: Omit<LifeEvent,"id"|"createdAt"|"updatedAt">): Promise<LifeEvent>`
- `update(event: LifeEvent): Promise<void>`
- `duplicate(eventId: Id): Promise<LifeEvent>`
- `delete(eventId: Id): Promise<void>`

### HousingRepository

- `listByVersion(planVersionId: Id): Promise<HousingAssumptions[]>`（4 タイプ）
- `getByType(planVersionId: Id, housingType: HousingType): Promise<HousingAssumptions | undefined>`
- `upsert(assumptions: HousingAssumptions): Promise<void>`
- `setSelected(planVersionId: Id, housingType: HousingType): Promise<void>`（isSelected 整合を取る）
- `applyPreset(planVersionId: Id, housingType: HousingType, preset: "conservative"|"base"|"optimistic"): Promise<void>`（任意：MVP で便利）

### ScenarioAssumptions（Version 配下）

（Repo を分けるか VersionRepo 内に含めるかは設計で決定）

- `listScenarioAssumptions(planVersionId: Id): Promise<ScenarioAssumptions[]>`
- `upsertScenarioAssumptions(value: ScenarioAssumptions): Promise<void>`

---

## Acceptance Criteria

- [ ] 上記 Repository インターフェースが TypeScript で定義されている
- [ ] B1 の型（Id/YearMonth/Plan/…）を参照しており整合している
- [ ] 主要画面の操作をカバーできる（プラン一覧/作成、月次一覧・入力、イベント一覧・作成、住宅前提編集、改定履歴）
- [ ] メソッド命名が一貫している（get/list/create/update/delete/upsert）
- [ ] エラー方針が明記されている（基本 throw）
- [ ] 将来 Supabase 実装が同じ interface で作れる前提が成立している

## Definition of Done

- [ ] PR が作成されレビュー完了
- [ ] インターフェースを使った「擬似実装例（ダミー Repo）」が 1 つでもコンパイル可能（任意だが推奨）
- [ ] docs に「どの画面がどの Repo メソッドを呼ぶか」簡易マッピングがある（箇条書きで OK）

---

## Dependencies

- B1（ドメインモデル型）
- B2（IndexedDB スキーマ設計：参照パターン整合）

## Follow-ups（関連チケット）

- B5. IndexedDB Repository 実装（全 Repo）
- B6. Supabase 用 Repository スタブ作成
