## 1) Decision（確定事項）

B4（Repository I/F 定義）を進めるために、MVP（IndexedDB）前提で **「迷いが出やすい設計点を先に固定」**します。結論は以下です（各項目で理由も書きます）。

---

## 2) Assumption（仮定）

- IndexedDB の tx は **「同一 DB・同一タブ内の単一トランザクション」**を基本にし、分散/非同期を跨がない。
- UI は client-only。Repo は `src/lib` 配下で完結（server action 等は未使用）。
- B1 の型は `id/createdAt/updatedAt` を基本フィールドとして持つ（無い場合は追加する前提で話します）。

---

## 3) Design Output（回答：不明点ごとの方針）

### ① 置き場が無い（`src/lib/repo/`）

**結論：作ります。構成は “interfaces/impl/index” の 3 層が最小で綺麗です。**

推奨構成：

- `src/lib/repo/interfaces/` … Repo の I/F（B4 の成果物）
- `src/lib/repo/indexeddb/` … IndexedDB 実装（B5 で実装）
- `src/lib/repo/index.ts` … まとめて export（DI しやすく）

（例）

- `src/lib/repo/interfaces/planRepo.ts`
- `src/lib/repo/interfaces/versionRepo.ts`
- `src/lib/repo/indexeddb/planRepo.ts`
- `src/lib/repo/indexeddb/versionRepo.ts`

---

### ② 例外方針（throw）だが、Repo 内でどこまで包むか

**結論：Repo は “包みすぎない”。ただし「文脈（which planId/ym）」だけ付与して throw。**

- そのまま throw：IndexedDB のエラーは原因追跡に有利
- ただし、呼び出し側が「どの操作で落ちたか」分かるようにするために
  Repo は **`RepoError`（薄いラッパ）**だけ付けるのがちょうど良い

推奨：

- `class RepoError extends Error { op; entity; meta; cause }`
- `throw new RepoError('PlanRepo.create', { planId }, err)` みたいに最小限

※ Result/Either 不要、throw で OK という方針と矛盾しません。

---

### ③ 取引境界（複数 store 更新を Repo 内 withTx かユースケース側か）

**結論：原則はユースケース側で tx を張る。例外として “原子的に守りたい不変条件” は Repo に専用メソッドで閉じ込める。**

- 基本：UseCase が `withTx()` を開始 → 複数 Repo に同じ tx を渡す
  （Plan + Version 作成などの “業務フロー” はユースケースの責務）
- 例外：**排他/整合が崩れたら致命的な操作**は Repo に「原子操作 API」を用意

  - 例：`HousingRepo.setSelected(versionId, type)`（同一 version 内で 1 つだけ selected）
  - 例：`VersionRepo.setCurrent(planId, versionId)`（後述）

この方針だと、B4 の I/F は「tx を受け取れる形」を持つのが綺麗です。

推奨 I/F 形：

- 全メソッドに `tx?: IDBTransaction` を optional で渡せる
- もしくは `RepoContext { tx? }` を渡す

---

### ④ ID/日時生成（Repo 生成か、呼び出し側か）

**結論：Repo が生成する（呼び出し側は “必須ビジネス値のみ” 渡す）。**

理由：

- 一貫性（createdAt/updatedAt の付け忘れ防止）
- upsert の境界も Repo が知っている方が安全

推奨：

- `create(input: NewPlanInput): Promise<Plan>`（id/at は Repo が付与）
- `upsert(input: PlanUpsertInput): Promise<Plan>`（存在判定 →createdAt 維持・updatedAt 更新）

例外として、テストやインポート用途で「外部 id 指定」を許可したい場合のみ

- `createWithId(...)` のような別 API（MVP は不要）

---

### ⑤ CurrentVersion 整合（Plan.currentVersionId と PlanVersion.isCurrent の二重管理）

**結論：二重管理は避けるのがベスト。MVP は “Plan.currentVersionId を正” に統一し、PlanVersion.isCurrent は持たない（または派生扱い）。**

理由：

- 二重管理は壊れる（IndexedDB はトリガーも制約も薄い）
- 「現在のバージョン」は Plan が指しているだけで十分

もし既に `PlanVersion.isCurrent` を型に入れてしまっている場合の次善策：

- **正は Plan.currentVersionId**
- `VersionRepo.setCurrent(planId, versionId)` を唯一の更新口にして、同一 tx で

  - Plan.currentVersionId 更新
  - （必要なら）PlanVersion.isCurrent の付け替え

- そして他からは isCurrent を直接書かない（内部専用）

→ どちらを正とするかの答え：**PlanRepository / VersionRepository どちらでもなく、API としては VersionRepo.setCurrent に寄せる**（「version を current にする」操作だから）。ただし実装は Plan も更新する。

---

### ⑥ 初期 Version 作成 API（createFromCurrent だけで十分？ createInitial を追加？）

**結論：C2 要件通り `createInitial` を追加します。**

理由：

- 初回作成は「current が無い」ので `createFromCurrent` だけだと分岐が増える
- 初期投入（C3）とも相性が良い

推奨 API：

- `VersionRepo.createInitial(planId, payload?)`：最初の version を作る（current 化も同時に）
- `VersionRepo.createFromCurrent(planId, changeNote?)`：改定版を複製作成（current 化は別 or オプション）

※ “初期作成は Plan 作成ユースケースにまとめる” でも良いですが、Repo I/F として `createInitial` があると C2 実装が綺麗です。

---

### ⑦ ScenarioAssumptions の扱い（別 Repo か、VersionRepo に含めるか）

**結論：MVP は VersionRepo に含める（version スコープの子要素として扱う）。**

理由：

- Repo が増えると DI/tx 配線が重くなる（IndexedDB 段階では特に）
- シナリオは「version の前提の一部」で、単体で独立操作が少ない

推奨：

- `VersionRepo.getScenarioSet(versionId)`
- `VersionRepo.upsertScenarioSet(versionId, scenarioSet)`
- `VersionRepo.ensureScenarioSet(versionId)`（C3 の初期投入にも使える）

将来 Supabase 化で正規化したくなったら `ScenarioRepo` を切り出せます（I/F 互換のまま移行しやすい）。

---

### ⑧ Monthly 詳細 API（MonthlyRepo に listItems/replaceItems を含めるか、別 Repo か）

**結論：MVP は MonthlyRepo に含める（MonthlyRecord と MonthlyItem は同じ集約として扱う）。**

理由：

- 実装も利用箇所も「月次詳細」画面に密結合
- tx も一緒に扱うことが多い（E8/E9 で record と items を同時に触る）

推奨 API：

- `MonthlyRepo.listItems(recordId)`
- `MonthlyRepo.replaceItems(recordId, items)`
- `MonthlyRepo.deleteByYm(planId, ym)`（record + items を tx で削除）

将来、Items が肥大化して独立最適化したくなったら分離で OK。

---

### ⑨ フィルタ命名（Event の type を LifeEvent.eventType と一致させるか）

**結論：`eventType` に統一**（`type` は避ける）。

理由：

- `type` は TS でも一般語すぎて衝突/誤読が増える
- UI/DB/Repo/フィルタ全てが揃うほど保守が楽

推奨：

- ドメイン：`LifeEvent.eventType`
- Repo 検索：`list({ eventType, ... })`
- UI フィルタ：`eventType`

（もし UI でカテゴリ表示が必要なら `eventType` と `category` を別にしても OK）

---

## 4) Risks（リスク）

- 二重管理（currentVersionId/isCurrent）を残すと、必ずどこかでズレます → どちらかを正に固定（推奨：Plan.currentVersionId）。
- tx 境界を Repo に寄せすぎると、UseCase がただの薄い呼び出しになり、後で仕様追加が辛くなります → 原則は UseCase 主導、整合が壊れる操作だけ Repo で原子化。
- Scenario を別 Repo にすると DI と tx 配線が急に複雑化 → MVP は VersionRepo 内包が安全。

---

## 5) Next（次に作るべきもの：最短ルート）

B4 の I/F を作る際は、まずこれだけ固定すると進みます：

1. `RepoContext/tx` を I/F に入れる（optional）
2. ID/日時生成は Repo 側
3. current は `VersionRepo.setCurrent(planId, versionId)` を唯一の更新口にする（正は Plan.currentVersionId）
4. VersionRepo に scenario 操作も含める
5. MonthlyRepo に items API を含める
